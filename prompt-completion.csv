prompt,completion
,"---
canonical_url: https://www.scaler.com/topics/crc-program-in-c/
title: CRC Program in C - Scaler Topics
description: Learn about CRC Program in C along with all the programs involved in it on Scaler topics.
category: C
author: Hari Sankar
---

:::section{.abstract}
## Overview
When sending data from a sender to a receiver, there are possibilities that the data sent as `digital signals` may get changed due to noise during the process of sending the data. Due to this, data received by the receiver may be different from the data sent by the sender. This change in data bit is called an **error** and to prevent such an error, the data received by the receiver is checked using different error detection algorithms. One such algorithm is the `Cyclic Redundancy Check algorithm`. 

:::



:::section{.scope}
## Scope
 + This article explains the principles used in the Cyclic Redundancy Check algorithm with examples.
 + Provides the implementation of the CRC program in C using two different methods.
 + Explains the algorithms and time complexity of the two different methods of implementing the CRC program in C.

:::


:::section{.main}
## Introduction
**Cyclic Redundancy Check** is an error detection algorithm used to check the validity of the data sent by the sender. In CRC, in addition to the data to be transmitted, the algorithm requires a **generator polynomial** that is used to compute the **check value** using binary division. The check value or the `CRC`  is sent along with the data to the receiver to check the validity of the data. 

The data that is to be sent to the receiver can be represented in the polynomial form with the degree of the polynomial as the bit positions. For example, the binary data `1010101` of length `7` can be represented as,
$$
{x^7+x^5+x^3+1}
$$
The bit value of `0` is not represented as the value of that representation is also `0`.

The generator polynomial can also be represented in binary. The degree of the generator polynomial must be greater than `0` and lesser than the degree of the data. The CRC can be classified into different standards based on the degree of the generator polynomial. The `CRC-8` standard use a generator polynomial of degree `8` and `CRC-16` uses a generator polynomial of degree `16`. A simple representation of the generator polynomial is given as follows.
$$
{x^5+ x^4+x^2}
$$
The above generator polynomial is represented in binary data as `00011010`.

:::section{.tip}
**Note :** Cyclic Redundancy Check can also be used as a hashing function and in such cases, the CRC-8 standard is not used as it can produce only 256(${2^8}$) values.
:::

:::section{.main}
The **steps involved** in CRC are as follows,
In the **sender side**,
 + The data of length, n, and the generator polynomial of length, l is prepared.
 + The data to be sent is appended with (l-1) number of zeros.
 + Binary division is performed with the data as dividend and the binary equivalent of the generator polynomial as the divisor. The remainder of the binary division is the check value.
 + The signal is sent with the check value appended to the end of the data.

The **mathematical representation** of check value or CRC is,
$$
CRC=remainder\ of [{data * \frac{x^n}{generator polynomial}} ] 
$$
Here, the n represents the number of bits in the generator polynomial
On the **receiver side**,
 + The data received again proceeds with binary division with the data as dividend and the binary equivalent of the generator polynomial as the divisor.
 + If the remainder of the binary division is zero then the data transmitted from the sender has no error. If the remainder is not zero, then the signal has been corrupted with an error.

The **process of binary division** follows the following steps and is similar to normal polynomial division,
 + Each step of the division involves XOR of divisor and dividend. The first n bits of the divisor are only used for this operation where n is the number of bits in the dividend. 
 + The quotient will be `1` or `0` based on the n-bit data. If the last bit of the data is `1`, then the quotient is `1` and if the last bit of the data is `0`, then the quotient is `0`.
 + Then the bit at the position n+1 is taken from the data and appended with the remainder of the above operation. This remainder becomes the divisor for the next operation.
 + The operation is repeated until all the bits in the data are used in the calculation.

The above procedure can be one of the interesting properties followed by the Cyclic Redundancy Check is,
``
 CRC(x^y^z) == crc(x) ^ crc(y) ^ crc(z).
``

The `^` symbol represents the XOR function. If we perform an XOR on 3 data and perform a CRC on the result, then the result of the CRC will be equivalent to CRC on the individual data and XOR with the results.
CRC can be used as 

:::section{.tip}
**Note :** The **XOR** operator returns 0 when both the inputs are the same and returns 1 in other cases.
:::





:::section{.main}
## Examples for Better Understanding

Let us consider the following example to understand how error checking is performed using Cyclic Redundancy Check.

Let the data be `1001101` and the binary equivalent of the generic polynomial is `1011`. On the sender side, the remainder can be found using binary division as follows,


![example-to-understand-how-error-checking.webp](https://scaler.com/topics/images/example-to-understand-how-error-checking.webp)



The remainder of the above division is `101`. This remainder is appended to the data to create the signal which will be sent to the receiver. The signal is `1001101101`.

Then error checking is performed on the receiver side as follows,


![error-checking-is-performed-on-the-receiver](https://scaler.com/topics/images/error-checking-is-performed-on-the-receiver.webp)

As the remainder is `0`, we can assure that there is no error in the received message.

Let us now consider the case, in which the message received is `1001001101` in which the 6th bit from last is inverted.


![showing-error-detection-in-the-receiver-side](https://scaler.com/topics/images/showing-error-detection-in-the-receiver-side.webp)

As the remainder is `111`, we can assure that there is an error in the message.
:::


:::section{.main}
## Implementation for CRC in C
There are **two methods** to implement the `CRC` program in the C programming language. The first method uses a character array and the next method uses bit manipulation techniques.

### Algorithm
 The **algorithm** used to implement the CRC program in C is as follows,
  
  + Get the data and generator polynomial.
  + Let n be the length of the generator polynomial.
  + Append n-1 zeros to data.
  + Call the CRC function.

The **algorithm** used in the CRC function is as follows,
 
 + Get the first n bits from the data.
 + If the first bit is `1`, then perform a xor operation with the first n bits of data and the generator polynomial.
 + Shift the bits by `1` position to leave the first bit.
 + Append a bit from the data. Repeat the process until all the bits in the data are appended.

The **algorithm** used in the XOR function is based on the following truth table of the XOR operator,

| Operand 1 | Operand 2 | Output(`^`) |
|:---------:|:---------:|:-----------:|
| 1         | 1         | 0           |
| 1         | 0         | 1           |
| 0         | 1         | 1           |
| 0         | 0         | 0           |

 + The first bit is compared with the second bit and if both the bits are the same, then the output is `0`.
 + If the bits are different, then the output is `1`.

The **algorithm** used to check for errors on the receiver side is as follows,
 
 + The data received again proceeds with a Cyclic Redundancy Check to find the remainder.
 + The remainder is iterated with conditions that there must be no 1 in the remainder and the length of the remainder must be lesser than the generator polynomial.
 + If all the elements are iterated, we can assure that there is no error, else there is error.


### Code

**Let us see the program for the implementation of CRC in C** 
```c
// Include headers
#include<stdio.h>
#include<string.h>
// length of the generator polynomial
#define N strlen(gen_poly)
// data to be transmitted and received
char data[28];
// CRC value
char check_value[28];
// generator polynomial
char gen_poly[10];
// variables 
int data_length,i,j;
// function that performs XOR operation
void XOR(){
    // if both bits are the same, the output is 0
    // if the bits are different the output is 1
    for(j = 1;j < N; j++)
    check_value[j] = (( check_value[j] == gen_poly[j])?'0':'1');
    
}
// Function to check for errors on the receiver side
void receiver(){
// get the received data
    printf(""Enter the received data: "");
    scanf(""%s"", data);
    printf(""\n-----------------------------\n"");
    printf(""Data received: %s"", data);
// Cyclic Redundancy Check
    crc();
// Check if the remainder is zero to find the error
    for(i=0;(i<N-1) && (check_value[i]!='1');i++);
        if(i<N-1)
            printf(""\nError detected\n\n"");
        else
            printf(""\nNo error detected\n\n"");
}

void crc(){
    // initializing check_value
    for(i=0;i<N;i++)
        check_value[i]=data[i];
    do{
    // check if the first bit is 1 and calls XOR function
        if(check_value[0]=='1')
            XOR();
// Move the bits by 1 position for the next computation
        for(j=0;j<N-1;j++)
            check_value[j]=check_value[j+1];
        // appending a bit from data
        check_value[j]=data[i++];
    }while(i<=data_length+N-1);
// loop until the data ends
}

int main()
{
    // get the data to be transmitted
    printf(""\nEnter data to be transmitted: "");
    scanf(""%s"",data);
    printf(""\n Enter the Generating polynomial: "");
    // get the generator polynomial
    scanf(""%s"",gen_poly);
    // find the length of data
    data_length=strlen(data);
    // appending n-1 zeros to the data
    for(i=data_length;i<data_length+N-1;i++)
        data[i]='0';
    printf(""\n----------------------------------------"");
// print the data with padded zeros
    printf(""\n Data padded with n-1 zeros : %s"",data);
    printf(""\n----------------------------------------"");
// Cyclic Redundancy Check
    crc();
// print the computed check value
    printf(""\nCRC or Check value is : %s"",check_value);
// Append data with check_value(CRC)  
    for(i=data_length;i<data_length+N-1;i++)
        data[i]=check_value[i-data_length];
    printf(""\n----------------------------------------"");
// printing the final data to be sent
    printf(""\n Final data to be sent : %s"",data);
    printf(""\n----------------------------------------\n"");
// Calling the receiver function to check errors
    receiver();
        return 0;
}
```
 + The `strlen()` function is used to find the length of a character array. The `string.h` header must be included to use this function.

**Output:**
```plaintext
Enter data to be transmitted: 1001101
Enter the Generating polynomial: 1011
----------------------------------------
Data padded with n-1 zeros : 1001101000
----------------------------------------
CRC or Check value is : 101
----------------------------------------
Final data to be sent : 1001101101
----------------------------------------
Enter the received data: 1001101101
-----------------------------
Data received: 1001101101
No error detected
```
As the data transmitted and received are the same, &&there is no error** in the signal.


**In the case of error**,
```plaintext
Enter the received data: 1001001101
-----------------------------
Data received: 1001001101
Error detected
```
Since the data send is different from the data received, there is an error in the signal.

### Complexity
 The **time complexity** and **space complexity** are used to represent the execution time and space required by the program. The time and space complexities are expressed using the [Big-O notation](https://www.scaler.com/topics/data-structures/time-complexity-in-data-structure/). Since there are two for loops implied at a time, the time complexity of the program is **O($${n^2}$$)**. The space complexity of the program is **O(n)** and is due to the single dimension character array used to store n  characters.
:::

:::section{.main}
## Implementation for CRC using Bit Manipulation
This method of implementing the `CRC program` in C uses bit manipulation techniques.

### Algorithm
The **algorithm** used to implement CRC in C using bit manipulation is as follows,
 + Get the data and generator polynomial.
 + Convert both the data and generator polynomial to decimal values.
 + Shift the bits in data by n-1 positions to append zeros at the end of data, where n is the length of the generator polynomial.
 + Find the number of bits to be shifted using the logarithmic function.
 + Shift the data by the computed number of bits and perform XOR operation with generator polynomial.
 + Find the remainder of the operation and append a bit of data to the remainder for further computation.
 + Repeat the process until all bits in data are utilized in the computation.

The **algorithm** used to convert decimal values to binary values is as follows,
 + Find the remainder by performing a modulo operation with the number and `2`.
 + Find the value of `10` raised to the power of count and multiply it with the remainder.
 + Sum the value found as a result of the previous step. 
 + Divide the decimal by `2` and increment the counter. Repeat the steps until the decimal becomes is not equal to `0`.

Let us consider an example of converting the decimal `5` to binary and walkthrough each step,

| Variables | STEP1 1 | STEP 2 | STEP 3  |
|:---------:|:-------:|:------:|:-------:|
| count     | 0       | 1      | 2       |
| rem       | 1       | 0      | 1       |
| tmp       | 1       | 10     | 100     |
| binary    | 1       | 1      | **101** |
| decimal   | 2       | 1      | 0       |


The **algorithm** used to convert binary values to decimal equivalent is as follows,
 + If the bit value is `1`, then find the value of that position by shifting the bits from the decimal number one by the required number of positions.

For example, consider the binary value 0010, then the decimal equivalent can be found by shifting the decimal number one by 1 position,
 `0001 << 1 => 0010` which has a value of 3.


### Code
```c
#include<stdio.h>
#include<math.h>
#include<string.h>
#define ull unsigned lli
#define lli long long int
int Decimal_to_Binary(int decimal)
{
// binary value
    ull binary = 0;
// counter
    int count = 0;
// remainder variable
    int rem=0; 
    while (decimal != 0) {
// perform modulo operation
        rem = decimal % 2;
// compute power of 10
        ull tmp = pow(10, count);
// add result to compute the binary number
        binary += rem * tmp;
// divide the decimal by 2
        decimal /= 2;
// increment count
        count++;
    }
    return binary;
}
 
lli Binary_to_Decimal(char binary[]){
    lli decimal = 0;
// Use bit shifting with 1 to compute the number
// sum the numbers to get the decimal equivalent
    for (int i=0; i<strlen(binary); i++){
        if (binary[i]=='1')
            decimal += 1 << (strlen(binary) - i - 1);
    }
    return decimal;
}
 
// function to compute CRC and codeword
void CRC(char data[], char gen_poly[]){
// length of the generator polynomial
    int length_gen = strlen(gen_poly);
// convert generator polynomial from binary to decimal
    lli generator_dec = Binary_to_Decimal(gen_poly);
// Convert data from binary to decimal
    lli data_dec = Binary_to_Decimal(data);
// Shift n-1 bits to the left in data to append zeros
    lli dividend = data_dec << (length_gen-1); 
// find the number of bits to shift for further computation.
    int shift_bits = (int) ceill(log2l(dividend+1)) - length_gen; 
// initialize variable for CRC or check value
    lli check_value;
// loop to find the check_value or CRC
    while ((dividend >= generator_dec) || (shift_bits >= 0)){
 // take the first four bits of the data 
 // perform XOR with the generator polynomial
        check_value = (dividend >> shift_bits) ^ generator_dec;               
// find the remainder of the operation
        dividend = (dividend & ((1 << shift_bits) - 1)) | (check_value << shift_bits);
// compute the number of bits to shift again
        shift_bits = (int) ceill(log2l(dividend + 1)) - length_gen;
    }
 // append the check value with the data
    lli final_data = (data_dec << (length_gen - 1)) | dividend;
// convert the decimal value to binary 
    printf(""Check value or CRC: %d\n"",Decimal_to_Binary(dividend));
// print the data to be transmitted
    printf(""Data to be sent:  %d"",Decimal_to_Binary(final_data));
}
 
int main(){
// Get the data
    char dataword[20];
    printf(""Enter the data to be transmitted: "");
    scanf(""%s"", dataword);
// Get the generator polynomial
    char generator[20];
    printf(""\nEnter the generator polynomial: "");    
    scanf(""%s"",generator);
// Calling the CRC function
    CRC(dataword, generator);
    return 0;
}
```
 + The `log2l()` function is used to find the logarithmic to the base 2 for a number and has the following syntax,
```c
long double log2l(long double x);
```
The function returns the logarithmic value as a type of `long double`
 + The `ceill()` function is used to round the value to the nearest maximum number. The syntax for the function is,
```c
long double ceill( long double arg );
```
For example, if the value is 6.25, then `ceill(6.25)` will return the value of 7.00.
 + The operators `<<` and `>>` are called bit shifting operators and are used to shift bits in the left and right direction.
 + The operator `&` is called the bitwise AND operator and is used to perform AND operation between two numbers and the `|` is called the bit wise OR operator and is used to perform OR operation between two numbers.

Let us consider an example sample implementation of the CRC function with the input data as `1001101` and the generator function as `1011`,

```c
Divident: 1001101 << 3 => 1001101000(decimal value is 617)
shift_bits: 6
Loop-----------
dividend >> shift_bits: 1001101000 >> 6 => 000001001
check_value:  000001001
              000001011
             -----------
              000000010 
             -----------
1 << shift_bits: 0001 << 6 => 1000000 (decimal=64) 
1 << shift_bits -1 : 63
dividend & ((1 << shift_bits) - 1) :
  1001101000
  0000111111
  ----------
  0000101000
  ----------
check_value << shift_bits: 10000000
dividend & ((1 << shift_bits) - 1)) | 
(check_value << shift_bits):
   0000101000
   0010000000
   ----------
   0010101000(decimal value is 168) -> first remainder
   ----------
------------- loop until data is utilized 

data_dec << (length_gen - 1): 1001101000
(data_dec << (length_gen - 1)) | dividend:
  1001101000 
  0000000101 -> The last remainder is 5
  ----------
  1001101101
  -----------
  
```

:::section{.tip}
**Note :** The log to the base 2 functions is used to find the number of bits present in the data. The general definition of log base 2 is to find the power of 2 needed to get the value of n, where n is the number given as input to the function.
 The `ceill()` function is used along with the log base 2 functions to find the number of bits which is then used to find the number of bits to shift.
:::

:::section{.main}
**Output:**
```plaintext
Enter the data to be transmitted: 1001101
Enter the generator polynomial: 1011
Check value or CRC: 101
Data to be sent:  1001101101
```

### Complexity

 The **time complexity** and **space complexity** are used to represent the execution time and space required by the program. The [ Big-O notation](https://www.scaler.com/topics/data-structures/time-complexity-in-data-structure/) is used to express the complexity of the program. Since only one `for` loop is implied at a time, the time complexity will be  **O(n)** and the space complexity of the program is **O(n)** and is due to the single dimension character array used to store the characters.

:::

:::section{.summary}
## Conclusion
 + `Cyclic Redundancy Check` is an error validation algorithm used to check if there is any error in the signal transmitted by the sender.
 + A generator polynomial is used to find the CRC value of the data and the data is transmitted along with the CRC.
 + The XOR operation is performed at each step of the process to find the value of CRC.
 + Validation is performed at the receiver side by checking if the CRC calculated on the receiver side is equal to zero.
 + The implementation of the CRC program in C can be done either by using a character array or by using the bit manipulation technique.
 + The time and space complexity of both algorithms is the same.

:::

"